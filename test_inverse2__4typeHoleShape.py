import torch
from vae1_4type import MeshVAE
import numpy as np
from disp_predictor1_4type import DispPredictor
from abc import ABC, abstractmethod
import math
from scipy.spatial import Delaunay, cKDTree
from collections import Counter, defaultdict
import pymeshlab as ml
import os

def exportOBJNodeGroup(path, nodes, group):
    f = open(path, "w")
    for id, node in enumerate(nodes):
        if id in group:
            f.write("v {} {} {} 1 0 0\n".format(str(node[0]), str(node[1]), str(node[2])))
        else:
            f.write("v {} {} {} 0 0 0\n".format(str(node[0]), str(node[1]), str(node[2])))

    f.close()
    
def exportOBJMesh(path, nodes, elems):
    f = open(path, "w")
    for id, node in enumerate(nodes):
        f.write("v {} {} {}\n".format(str(node[0]), str(node[1]), str(node[2])))

    for el in elems:
        text = "f "
        for nid in el:
            text += "{} ".format(nid + 1) 
        f.write(text + "\n")
    f.close()

def find_boundary_edges(elements):
    """
    Find boundary edges of a triangular FEM mesh in 3D.
    
    Args:
        elements (np.ndarray): (num_elements, 3) array representing triangular elements.
    
    Returns:
        set: Set of boundary edges (each edge is a tuple of two sorted node indices).
    """
    edge_counter = Counter()

    # Count the occurrences of each edge
    for tri in elements:
        edges = [(tri[0], tri[1]), (tri[1], tri[2]), (tri[2], tri[0])]
        for edge in edges:
            edge_counter[tuple(sorted(edge))] += 1

    # Extract boundary edges (edges appearing only once)
    boundary_edges = {edge for edge, count in edge_counter.items() if count == 1}
    
    return boundary_edges

def find_holes(boundary_edges):
    """
    Detect holes in a triangular mesh based on boundary edges.
    
    Args:
        boundary_edges (set): Set of boundary edges.
    
    Returns:
        list: List of boundary loops, where each loop is a list of connected vertices.
    """
    # Create adjacency list for boundary edges
    edge_graph = defaultdict(set)
    for v1, v2 in boundary_edges:
        edge_graph[v1].add(v2)
        edge_graph[v2].add(v1)

    # Find loops using a greedy traversal
    visited = set()
    holes = []

    for start_vertex in edge_graph:
        if start_vertex in visited:
            continue
        
        # Perform a traversal to find a cycle
        loop = []
        current = start_vertex
        prev = None
        
        while current not in visited:
            visited.add(current)
            loop.append(current)
            
            # Find the next vertex in the loop
            next_vertices = [v for v in edge_graph[current] if v != prev]
            if not next_vertices:
                break  # No more connections, stop

            prev = current
            current = next_vertices[0]  # Continue along the next available edge

        if len(loop) > 2:
            holes.append(loop)

    return holes

def write_grid_fixed(node_id, cp, x1, x2, x3, cd=0, ps='', seid=''):
    return f"GRID    {node_id:>8}{cp:>8}{x1:>8.4f}{x2:>8.4f}{x3:>8.4f}{cd:>8}{ps:>8}{seid:>8}".rstrip()

def WriteNastran(path, nodes, elems):
    # a = np.linalg.norm(nodes, axis=1)
    # b = np.where(abs(a-radius)<tol)[0]
    boundary_edges = find_boundary_edges(elems)
    holes = find_holes(boundary_edges)
    # if (len(holes) != 2):
    #     print("something wrong")
    #     return False
    hole_range = []
    for hole in holes:
        hole_range.append(nodes[hole].max(0) - nodes[hole].min(0))
    holes1_range = nodes[holes[0]].max(0) - nodes[holes[0]].min(0)
    holes2_range = nodes[holes[1]].max(0) - nodes[holes[1]].min(0)

    amax = np.argmax(hole_range,axis=0)
    if len(np.unique(amax)) > 1:
        print("something wrong")
        return False
    else:
        b = np.unique(holes[amax[0]])
    # if holes1_range[0] > holes2_range[0] and holes1_range[1] > holes2_range[1]:
    #     b = np.unique(holes[0])
    # elif holes1_range[0] < holes2_range[0] and holes1_range[1] < holes2_range[1]:
    #     b = np.unique(holes[1])
    # else:
    #     print("something wrong")
    #     return False
    
    exportOBJNodeGroup(path + "/bc.obj", nodes, b)

    loading_node = [i for i in range(len(nodes)) if i not in b]
    exportOBJNodeGroup(path + "/load.obj", nodes, loading_node)

    f = open(path + "/circ.bdf", "w")
    f.write("$ Generated by ICEMCFD -  NASTRAN Interface Vers.  14.0.0\n")
    f.write("$ Nastran input deck\n")
    f.write("SOL 101\n")
    f.write("CEND\n")
    f.write("SPC = 1\n")
    f.write("LOAD = 1\n")
    f.write("$\n")
    f.write("BEGIN BULK\n")
    f.write("$\n")
    for id, node in enumerate(nodes):
        #f.write("{0:<8s}{1:8d}{2:8g}{3:8g}{4:8g}\n".format("GRID", id + 1, round(node[0], 5), round(node[1],5), round(node[2], 5)))
        #f.write("{},{},{},{},{}\n".format("GRID", id + 1, round(node[0], 5), round(node[1],5), round(node[2], 5)))
        f.write(write_grid_fixed(id+1, 0, node[0], node[1], node[2]) + "\n")
        
    for id, elem in enumerate(elems):
        f.write("{0:<8s}{1:8d}{2:8d}{3:8d}{4:8d}{5:8d}\n".format("CTRIA3", id + 1, 1, elem[0] + 1, elem[1] + 1, elem[2] + 1))

    f.write("{0:8s}{1:16d}{2:16g}{3:16g}\n".format("MAT1*", 1, E, nu))
    f.write("{0:8s}{1:8d}{2:8d}{3:8g}\n".format("PSHELL", 1, 1, thickness))
    for id in b:
        f.write("{0:8s}{1:8d}{2:8d}{3:8d}{4:8g}\n".format("SPC", 1, id + 1, 123456, 0))

    #load = random.randint(3000,10000)
    for id in range(len(elems)):
        f.write("{0:8s}{1:8d}{2:8d}{3:8g}\n".format("PLOAD4", 1, id + 1, 80000))
        # f.write("{0:8s}{1:8d}{2:8d}{3:8g}\n".format("PLOAD4", 1, id + 1, -load))
    
    #f.write("{0:8s}{1:8d}{2:8d}{3:8d}{4:8g}{5:8g}{6:8g}{7:8g}\n".format("FORCE", 1, loading_node + 1, 0, 1.0, 0.0, 0.0, -loading))

    f.write("LOAD    2       1.      1.      1\n")
    f.write("SPCADD  3       1\n")
    f.write("ENDDATA\n")
    f.close()

    np.savez_compressed(path + "/data.npz", node=nodes, elem=elems, BDNode=b)
    return True

class PlateShape(ABC):
    def __init__(self):
        self.node = None
        self.elem = None

    @abstractmethod
    def Generate(self, size):
        if self.node is None and self.elem is None:
            print("Not Implemented!")
        
        ms = ml.MeshSet()
        m = ml.Mesh(self.node, self.elem)
        ms.add_mesh(m, "mesh_1")
        ms.meshing_isotropic_explicit_remeshing(iterations=10, targetlen=ml.PureValue(size))
        
        self.node = ms.current_mesh().vertex_matrix()
        self.elem = ms.current_mesh().face_matrix()

        return ms.current_mesh().vertex_matrix(), ms.current_mesh().face_matrix()
    
    def OX_Mirror(self, node, elem, tol = 1e-6):
        elem.extend([[elem[i][1]+ len(node), elem[i][0] + len(node), elem[i][2]+ len(node)] for i in range(len(elem))])
        node.extend([[node[i][0], node[i][1]* -1, node[i][2]] for i in range(len(node))])
        node = np.array(node)
        # dist = np.linalg.norm(node[:,None,:] - node[None,:,:], axis=-1)
        # d = np.where(dist < 1e-6)
        # e = [[d[0][i], d[1][i]] for i in range(len(d[0])) if d[0][i] != d[1][i]]
        tree = cKDTree(node)
    
        # Find nodes within `tol` distance of each other
        groups = tree.query_ball_tree(tree, tol)

        # Use disjoint-set logic to assign each node to a unique representative
        N = len(node)
        representative = np.arange(N)

        for i, group in enumerate(groups):
            min_idx = min(group)
            for j in group:
                representative[j] = min(representative[j], min_idx)

        # Make representative labels consistent
        for i in range(N):
            while representative[i] != representative[representative[i]]:
                representative[i] = representative[representative[i]]

        # Map old node indices to compact new indices
        unique_reps, new_indices = np.unique(representative, return_inverse=True)
        node = node[unique_reps]
        elem = new_indices[elem]
        return node, elem

    def OY_Mirror(self, node, elem, tol = 1e-6):
        elem.extend([[elem[i][1]+ len(node), elem[i][0] + len(node), elem[i][2]+ len(node)] for i in range(len(elem))])
        node.extend([[node[i][0] * -1, node[i][1], node[i][2]] for i in range(len(node))])
        node = np.array(node)
        # dist = np.linalg.norm(node[:,None,:] - node[None,:,:], axis=-1)
        # d = np.where(dist < 1e-6)
        # e = [[d[0][i], d[1][i]] for i in range(len(d[0])) if d[0][i] != d[1][i]]
        tree = cKDTree(node)
    
        # Find nodes within `tol` distance of each other
        groups = tree.query_ball_tree(tree, tol)

        # Use disjoint-set logic to assign each node to a unique representative
        N = len(node)
        representative = np.arange(N)

        for i, group in enumerate(groups):
            min_idx = min(group)
            for j in group:
                representative[j] = min(representative[j], min_idx)

        # Make representative labels consistent
        for i in range(N):
            while representative[i] != representative[representative[i]]:
                representative[i] = representative[representative[i]]

        # Map old node indices to compact new indices
        unique_reps, new_indices = np.unique(representative, return_inverse=True)
        node = node[unique_reps]
        elem = new_indices[elem]
        return node, elem

    def GenerateBoundaryEdges(self):
        edge2key = dict()
        edges = []
        edges_count = 0
        share_edges = dict()
        for face_id, face in enumerate(self.elem):
            faces_edges = []
            for i in range(3):
                cur_edge = (face[i], face[(i + 1) % 3])
                faces_edges.append(cur_edge)
            for idx, edge in enumerate(faces_edges):
                edge = tuple(sorted(list(edge)))
                faces_edges[idx] = edge
                if edge not in edge2key:
                    edge2key[edge] = edges_count
                    edges.append(list(edge))
                    share_edges[edge] = 1
                    edges_count += 1
                else:
                    share_edges[edge] += 1

        BD_edges = []
        for ed in share_edges:
            if share_edges[ed] == 1:
                BD_edges.append(int(ed[0]))
                BD_edges.append(int(ed[1]))
        return BD_edges
    
class RectangularPlateWithCircularHole(PlateShape):
    def __init__(self, diameter, width, height, d=16):
        super().__init__()
        self.r = diameter/2
        self.w = width
        self.h = height
        self.d = d
    
    def Generate(self, size, a=1, b=1):
        self.node = []
        self.elem = []
        angle = 0
        step = 360 / (self.d)
        # a = random.uniform(0.1,1)
        # b = random.uniform(0.1,1)
        for i in range(5):
            self.node.append([self.r*a*math.cos(angle*math.pi/180.0), self.r*b*math.sin(angle*math.pi/180.0), 0])
            angle += step

        self.node.append([self.w/2,0,0])
        self.node.append([self.w/2,self.h/2,0])
        self.node.append([0,self.h/2,0])

        self.elem = [[0,5,1], [1,5,2],[2,5,6],[2,6,3],[3,6,7],[3,7,4]]
        
        self.node.extend([[self.node[i][0] * -1, self.node[i][1], self.node[i][2]] for i in range(len(self.node) - 1) if i != 4])

        self.elem.extend([[12, 8, 9], [12, 9, 10], [12, 10, 13], [13, 10, 11], [13, 11, 7], [7, 11, 4]])
        
        self.node.extend([[self.node[i][0], self.node[i][1] * -1, self.node[i][2]] for i in range(1, len(self.node)) if i != 8 and i != 5 and i != 12])
        
        self.elem.extend([[5, 0, 14], [5, 14, 15], [5, 15, 18], [18, 15, 16], [18, 16, 19], [19, 16, 17], [8,12,20], [20,12,21],[21,12,23], [21,23,22], [22,23,19],[22,19,17]])
        return super().Generate(size)
            
class RectangularPlateWithRectangularHole(PlateShape):
    def __init__(self, width, height, hole_width, hole_height):
        super().__init__()
        self.w = width
        self.h = height
        self.h_w = hole_width
        self.h_h = hole_height

    def Generate(self, size):
        self.node = [[self.h_w/2, 0,0], [self.w/2, 0,0], [self.w/2, self.h/2,0], [0, self.h/2,0], [0, self.h_h/2, 0], [self.h_w/2, self.h_h/2,0]]
        self.elem = [[0,1,5], [1,2,5],[2,3,5],[5,3,4]]
        self.node, self.elem = self.OY_Mirror(self.node, self.elem)
        self.node, self.elem = self.OX_Mirror(self.node.tolist(), self.elem.tolist())
        
        return super().Generate(size)
    
class RectangularPlateWithDiamondHole(PlateShape):
    def __init__(self, width, height, d1, d2):
        super().__init__()
        self.w = width
        self.h = height
        self.d1 = d1
        self.d2 = d2

    def Generate(self, size):
        self.node = [[self.d1/2, 0,0], [self.w/2, 0,0], [self.w/2, self.h/2,0], [0, self.h/2,0], [0, self.d2/2, 0]]
        self.elem = [[0,1,2], [0,2,4],[2,3,4]]
        self.node, self.elem = self.OY_Mirror(self.node, self.elem)
        self.node, self.elem = self.OX_Mirror(self.node.tolist(), self.elem.tolist())
        
        return super().Generate(size)

class RectangularPlateWithHexaHole(PlateShape):
    def __init__(self, width, height, a):
        super().__init__()
        self.w = width
        self.h = height
        self.a = a

    def Generate(self, size):
        self.node = [[self.a/2, 0,0], [self.w/2, 0,0], [self.w/2, self.h/2,0], [0, self.h/2,0], [0, self.a*math.sqrt(3)/4, 0], [self.a/4, self.a*math.sqrt(3)/4,0]]
        self.elem = [[0,1,5], [1,2,5],[2,3,5],[5,3,4]]
        self.node, self.elem = self.OY_Mirror(self.node, self.elem)
        self.node, self.elem = self.OX_Mirror(self.node.tolist(), self.elem.tolist())
        
        return super().Generate(size)    

def ExportMeshAndAnalysisFile(name, plate_type, a, b, c, isWriteAnalysis):
    if plate_type == 0:
        shape = RectangularPlateWithCircularHole(width=a, height=b, diameter=c)
    elif plate_type == 1:
        shape = RectangularPlateWithRectangularHole(width=a, height=b, hole_width=c, hole_height=c)
    elif plate_type == 2:
        shape = RectangularPlateWithDiamondHole(width=a, height=b, d1=c, d2=c)
    else:
        shape = RectangularPlateWithHexaHole(width=a, height=b, a=c)
    node, elem = shape.Generate(0.05)

    x = node[:,0]
    y = node[:,1]

    z = np.sqrt(((a**2 + b**2)**0.5)*1.8 - node[:,0]**2 - node[:,1]**2)
    node = np.stack([x,y,z], axis=1)

    if not os.path.exists("./reconstruct/{}".format(name)):
        os.mkdir("./reconstruct/{}".format(name))

    exportOBJMesh("./reconstruct/{}/mesh.obj".format(name), node, elem)
    if isWriteAnalysis:
        WriteNastran("./reconstruct/{}/".format(name), node, elem)

E = 10.92e11
nu = 0.3
thickness = 2.54e-3
loading = 6895
device = "cuda:1"
recon_nodes_num = 4096
latent_dim = 64
vae = MeshVAE(point_cloud_node=4096,
                                                 point_cloud_output=recon_nodes_num,
                                                 features=3,
                                                 bottleneck=latent_dim,
                                                 num_class=16,
                                                 num_layer=4)
vae.load_state_dict(torch.load("./results/vae1/271.pth", map_location="cpu"))

disp_predictor = DispPredictor(latent_dim=latent_dim, output_dim=1)
disp_predictor.load_state_dict(torch.load("./results/disp_predictor1/501.pth", map_location="cpu"))

device = "cuda:1"

vae.to(device)
disp_predictor.to(device)
vae.eval()
disp_predictor.eval()

z = torch.randn(1, 64, requires_grad=True, device=device)
optimizer = torch.optim.Adam([z], lr=1e-2)

ref_data = torch.load("./dataset2/train/.cached/4_2.410703170364366x2.763907037451755x1.5557123293218253_shape0.pth")
ref_node = ref_data["recon_nodes"].to(device)

data_stat = np.load("./dataset2/train/.cached/data_decribe.npz", encoding='latin1', allow_pickle=True)
std = data_stat["std"]
minimum = data_stat["min"]
target_disp = (torch.tensor([[0.0002]], dtype=torch.float32, device=device) - minimum[-1]) / std[-1]

with torch.no_grad():
    ref_z = vae.Get_z_representation(ref_node.unsqueeze(0))
for step in range(1000):
    pred_disp = disp_predictor(z)
    loss = (pred_disp - target_disp).pow(2).mean() #+ 0.001 * torch.norm(z - ref_z)**2
    
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()

    if step % 10 == 0:
        print(f"Step {step}, Loss: {loss.item():.6f}, Predicted: {pred_disp.item():.4f}")

plate_probs, continuous_params = vae.decoder(z)
continuous_params = continuous_params.detach().cpu()
plate_type = torch.argmax(plate_probs, dim=1)
continuous_params = (continuous_params*std[:-3] + minimum[:-3]).squeeze().tolist()
print(continuous_params)
print(plate_type.item())
ExportMeshAndAnalysisFile("generated",  plate_type.item(), 
                          continuous_params[0], continuous_params[1], 
                          continuous_params[2], True)